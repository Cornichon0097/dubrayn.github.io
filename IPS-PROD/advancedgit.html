<!DOCTYPE html>
<html>
  <head>
    <title>IPS-DEV</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="core/fonts/mono.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/animate.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/cinescript.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/style_core.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/mermaid.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/gitgraph.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/style_ensiie.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/katex.css"> 
  </head>
  <body>
    <textarea id="source" readonly>

layout: true
class: animated fadeIn middle numbers

.footnote[
`IPS-DEV` - N. Dubray - ENSIIE - 2019 - [:book:](../index.html)
]

---

# `git` - Advanced techniques

.row[
.column.w80[

## Branches, remotes and subprojects

* `push --set-upstream` - Push branch to remote.
* `fetch` + `merge` vs. `pull` - Discussion on the issues with `pull`.
* `fast-forward` - Automatic transparent merging.
* `submodule` / `subtree` - Share code between projects. 
* `merge -s` - Merging priorities.

## Debugging / cleaning

* `bisect` - Go bug hunting !
* `blame` / `annotate` / `log` - Who wrote what ? When ?
* `cherrypick` / `cherry` - Apply a commit from a different branch.
* `grep` - Find a pattern in a project.
* `stash` - "Pause" your work. 
* `clean` - Clean your project.

## Extract from project

* `format-patch` / `apply` / `am` - Use patches.
* `archive` / `fetch --depth` / `clone --depth` - Do not use full history.

## Modify history :warning:

* `commit --amend` - Change the last commit.
* `push --force` - Replace remote's history.
* `reset` / `revert` - Undo some changes.
* `rebase` / `rebase -i` / `merge --squash` - Move and squash commits.
]
.column.w20.middle[
![](images/git_logo.png)
]
]

---

# Upstream branches / local branches

.hcenter.w70[
![](images/branches.png)
]
.hcenter[ [source](https://devconnected.com/how-to-set-upstream-branch-on-git/) ]

## How are they useful ?

:arrow_right: Know if you are ahead of upstream branches.  
:arrow_right: Merge with upstream branches even when being offline.  
:arrow_right: Use `git push`, `git fetch` and/or `git pull` without arguments.  

---

# Remotes

## Unofficial definition of a remote
**A remote is a nickname for an upstream repository.**  
:arrow_right: The special remote `origin` is automatically created when cloning.

## List remotes
* `git remote`: list defined remotes.
* `git remote -v`: list defined remotes for fetching and pushing.
* `git remote show REMOTE`: print detailed information on REMOTE.
* See also `[remote "xxx"]` in `.git/config`.

```text
*$ git clone main local_dev
Cloning into 'local_dev'...
done.
*$ cd local_dev/ && cat .git/config
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote "origin"]
        url = /home/dubrayn/temp/git/main
        fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
        remote = origin
        merge = refs/heads/master
*$ git remote
origin
*$ git remote -v
origin  /home/dubrayn/temp/git/main (fetch)
origin  /home/dubrayn/temp/git/main (push)
```

:arrow_right: `git remote add remote2 /some/path/toto.git`: add remote to project.

---

# Local branches

## Unofficial definition of a branch

**A branch is a name for a commit and its ancestors.**  
:arrow_right: Branches are light objects, do not refrain from using them.  

## Two types of local branches

* **non-tracking branches**, seen by `git branch` (often miscalled "local branches"),
* **remote tracking branches**, seen by `git branch -r`.

## Remote tracking branches

:arrow_right: A **remote tracking branch** is a **local branch** connected to a **remote branch**.
* Format for a remote tracking branch: `remote/branch`.
* Operations on remote tracking branches:
 * `git fetch remote`: update.
 * `git merge remote/branch`: merge from.
 * `git checkout --track -b localbranch remote/branch`: create local branch from.
 * `git branch -vv`: show branch remote tracking information (if any).

---

# Local branches - example

```text
*$ git branch
 * master
*$ git branch -r
   origin/HEAD -> origin/master
   origin/master
   origin/newbranch
*$ git fetch origin
*$ git merge origin/newbranch
Already up to date.
*$ git checkout --track -b newbranch origin/newbranch
Branch 'newbranch' set up to track remote branch 'newbranch' from 'origin'.
Switched to a new branch 'newbranch'
*$ git branch
   master
 * newbranch
*$ git branch -v
   master    07d7c5f first commit
 * newbranch 07d7c5f first commit
*$ git branch -vv
   master    07d7c5f [origin/master] first commit
 * newbranch 07d7c5f [origin/newbranch] first commit
*$ git checkout -b otherbranch
Switched to a new branch 'otherbranch'
*$ git branch -vv
   master      07d7c5f [origin/master] first commit
   newbranch   07d7c5f [origin/newbranch] first commit
 * otherbranch 07d7c5f first commit
```

:arrow_right: The remote tracking branch linked to a local non-tracking branch is also called the "upstream branch". 

---

# Remote tracking branches and upstream branches

## Remove branches
* `git branch -r -d somebranch`: remove a remote tracking branch.
* `git push origin --delete somebranch`: remove an upstream branch.

## Link / unlink branches
* `git push --set-upstream origin HEAD`:
 * create upstream branch (if needed),
 * create remote tracking branch,
 * link upstream branch and remote tracking branch,
 * link remote tracking branch to current branch ("set upstream branch for current branch").
* `git branch -u origin/master`: link existing remote tracking branch and current branch.
* `git branch --unset-upstream`: unlink remote tracking branch and current branch.

:arrow_right: It is also possible to edit `.git/config`.

```text
*$ cat .git/config
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote "origin"]
        url = /home/dubrayn/temp/git/main
        fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
        remote = origin
        merge = refs/heads/master
[branch "newbranch"]
        remote = origin
        merge = refs/heads/newbranch
```

---

# `git fetch + git merge` vs. `git pull`

:warning: Do not use `git pull`,  
:arrow_right: use `git fetch`, then `git merge` instead.  

* Why ? Because `git pull` does a lot of magic under the hood, to make it "just work".
* When it doesn't work, it is difficult to know why.

* `git fetch` gets new remote branches, advances remote tracking branches, gets tags, gets needed objects...
* `git fetch` does not change the working tree
* `git fetch -p` remove remote tracking branches that correspond to deleted branches on the remote

:arrow_right: `git merge` as usual

* `git merge -s ours`
* `git merge -s theirs`

---


# `git stash`

* what ? Save your uncommitted changes (staged and unstaged), 
* when ? Be working on something, have to switch to something else, but don't want to commit
* stashing
* re-applying `git stash pop`
* stashing un-tracked or ignored files `git stash -u`, `git stash -a`
* multiple stashes `git stash list` `git stash save "message"` `git stash pop stash@{1}`
* viewing stash diffs `git stash show` `git stash show -p`
* partial stash (interactive) `git stash -p`
* stash -> branch `git stash branch newbranch stash@{2}`
* cleaning stash `git stash drop stash@{1}`
* how does it work ? OPTIONAL

---

# `git clean`

**What ?** Recursively remove files that are not under version control, starting from current directory.  
**When ?** You want to come back to a "clean state".  

## :warning: Dangerous options for `git clean`
* remove ignored files with `-x`
* remove untracked directories with `-d`
* `-n` to show what would be removed, do not remove anything
* `-i` interactive

```text
*$ git status
On branch master
Your branch is up to date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        titi
        toto/

nothing added to commit but untracked files present (use "git add" to track)
*$ git clean -x -d
fatal: clean.requireForce defaults to true and neither -i, -n, nor -f given; refusing to clean
*$ git clean -x -d -i
Would remove the following items:
  titi   toto/
 *** Commands ***
  1: clean  2: filter by pattern  3: select by numbers  4: ask each  5: quit  6: help
What now> 1
Removing titi
Removing toto/
```

## :warning: Dangerous options for `git clean`
* remove ignored files with `-x`
* remove untracked directories with `-d`
* `-n` to show what would be removed, do not remove anything
* `-i` interactive

---

# `git bisect`

* what ? perform a binary search (bisection) on the history of a project
* when ? quickly identify which commit introduced a bug
* `git bisect start`: start the bisection
* `git bisect bad`: bad case (HEAD by default)
* `git checkout oldcommit`: get  an old commit
* `git bisect good`: declare that this commit is OK
* `git bisect skip`: declare that this commit is untestable
* `git bisect reset`: stop the bisection

TODO example

---

# `git blame` / `git annotate` / `git log`

.hcenter.shadow.w30[
 ![](images/shirt.jpg)
]
* what ? See who wrote what in a file
* when ? When you need to blame someone - hint: 99% of the time, it is you
* [link](https://www.redbubble.com/people/spacelake/works/24756596-git-blame-ruining-friendships-since-2005?p=t-shirt)

* `git blame` show options
* `git blame FILE` view content of file annotated with last author of each line
* `git blame -L start,stop FILE` process only line range of FILE

* `git annotate` different output format than `git blame`, backward compatibility with old scripts
* when was a line added ? `git log -Spattern FILE`

---

# `git cherry-pick` / `git cherry`

* what ? apply a commit from a different branch
* when ? do not want to merge full branch, only interested in a specific commit - typically: bug fix
* `git cherry-pick COMMIT`


* `git cherry` is different : allows to view if commits have been cherry-picked (see `man git-cherry`)

---

# `fast-forward` - Automatic transparent merging

:arrow_right: If you merge a remote tracking branch onto a local branch and the remote tracking branch has not been modified, `git` is using `fast-forward` by default.

.row.hcenter.w80[
.column.w30.middle[
.hcenter[
## fast-forward
]
]
.column.w5.middle[## :arrow_left:]
.column.w30.middle[
.hcenter[
## local
]
]
.column.w5.middle[## :arrow_right:]
.column.w30.middle[
.hcenter[
## no fast-forward
]
]
]

.row.hcenter.w80[
.column.w30[
<canvas id='gitFF0'></canvas>
]
.column.w5.middle[]
.column.w30[
<canvas id='gitFF1'></canvas>
]
.column.w5.middle[]
.column.w30[
<canvas id='gitFF2'></canvas>
]
]

:warning: It can be hard to "revert" a merge with the automatic fast-forward (where did the merge happen ?).  
:arrow_right: To disable fast-forward: `git merge --no-ff`, `git pull --no-ff`.  
:arrow_right: To **globally** disable fast-forward:

```text
$ git config --global merge.commit no
$ git config --global merge.ff no
```

---

# `submodule` - Clone another project inside your project.

## Possible reasons:

* Avoid code duplication.
* Develop two projects simultaneously.
* Split a big project into smaller ones.

:+: The origin of the subproject is kept: easy to push to, semi-easy to pull from.  
:warning: `git clone` will not clone the subproject: hard for noobs.

```text
*$ git submodule add https://github.com/dubrayn/superlib lib/superlib
Cloning into ‘lib/superlib’…
remote: Counting objects: 17, done.
remote: Compressing objects: 100% (16/16), done.
remote: Total 17 (delta 0), reused 17 (delta 0)
Unpacking objects: 100% (17/17), done.
Checking connectivity... done.
*$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   .gitmodules
    new file:   lib/superlib
*$ cat .gitmodules
[submodule “lib/superlib”]
      path = lib/superlib
      url = https://github.com/dubrayn/superlib
```

:arrow_right: cloning with subprojects: `git clone --recursive`.  
:arrow_right: updating subprojects: `git submodule update`.

---

# `subtree` - Copy another project inside your project.

## Possible reasons:

* Avoid code duplication.
* Develop two projects simultaneously.
* Split a big project into smaller ones.

:warning: The origin of the subproject is lost: hard to push to, semi-easy to pull from.  
:+: `git clone` will clone the subproject: easy for noobs.  
:warning: The history of your project will be polluted by the history of the subproject.  

TODO explications pas claires

## `git` subtree

```text
TODO
```

* cloning subtrees: nothing to do


---

# `submodule` vs. `subtree` - Conclusion ?

.hcenter.shadow.w30[
![](images/inception.jpg)
]


---

# `git format-patch` + `git apply` / `git am`

* create one patch for the current branch (forked from master): `git format-patch master --stdout > my_super_patch.patch`
* check the patch: `git apply --stat  my_super_patch.patch`  TODO add example
* test  the patch: `git apply --check my_super_patch.patch`  TODO add example
* apply the patch: `git am --signoff < my_super_patch.patch` TODO add example
* or `git apply my_super_patch.patch` TODO add example

---

# `git archive` / `git fetch --depth` / `git clone --depth`

* what ? get a local copy of a project without the full history
* when ? when the full history is not needed

* last 3 commits only: `git fetch --depth 3` / `git clone --depth 3`  
:warning: cannot be fetched, cloned or pushed to.

* no history, no git: `git archive master | gzip > latest.tgz`
* no history, no git: `git archive master | bzip2 > latest.tar.bz2`

---

# `git grep`

* what ? Search project for pattern
* when ? Looking for something
* `git grep some_pattern`
* `git grep --color -n -P some_pattern` (line numbers, color, regexp)
* `--no-index`: search in untracked files too
* `-i`: ignore case
* `-I`: do not match binary files
* `-w`: word only
* `-v`: invert match

TODO example

---

# :warning: WARNING :warning:

The following commands can modify the history of a project.  
:warning: Use them only for local projects. If your project has been cloned somewhere, do not use them.

---

# `git commit --amend` - Change the last commit

## Possible reasons:

* You have made a mistake in the last commit message.
* You have forgotten a file in the last commit.

:warning: **Your commit must be private**.

:arrow_right: `git commit --amend`: change the last commit message and content (opens editor).  
:arrow_right: `git commit --amend -m "new message"`: same without opening the editor.  
:arrow_right: `git commit --amend --no-edit`: change the last commit content, keep the commit message.

```text
TODO
```

---

# `git push --force` - Replace remote's history

## Possible reasons:

* The remote history is a mess.

:warning: **If the remote is public, and local versions of it exist, You can loose some commits**.

:arrow_right: `Github` proposes **protected branches**: no `git push --force` allowed on them.

```text
TODO
```

&nbsp;

## Variant: `git push --force-with-lease`

:arrow_right: Check that remote and local are in sync before pushing with `--force`.  
:warning: if someone did a `git fetch` without `git merge`, a branch can be overwritten (cf. [this example](https://blog.developer.atlassian.com/force-with-lease/)).

```text
TODO
```

---

# `git reset`

**What ?** Undo some changes  
**When ?** Your local project history is a mess, You want to "unstage" some files, to give up an idea...
* `git reset --soft` (HEAD)
* `git reset --mixed` (HEAD + staging index)
* `git reset --hard` (HEAD + stagin index + working directory)
* `git reset` = `git reset --mixed HEAD`

TODO examples

---

# `git revert`

* what ? cancel a commit
* when ? You want to fix a bug introduced by a single commit, without removing the commit

* `git revert COMMIT`: create a commit "canceling" another one
* `-n` or `--no-commit`: modify, stage but does not commit

:arrow_right: far better than `git reset`, since it does not modify the history of the project

TODO: example [link](https://www.atlassian.com/git/tutorials/undoing-changes/git-revert)

---

# `git rebase` - Move branches around

.row[
.column.w40.middle[
:arrow_right: "Attach" a branch to **another commit**.  

## Possible reasons:
* You want to obtain a nice linear history (aesier use of `git bisect`).
* You TODO

* `git rebase master` [link](https://coderefinery.github.io/git-branch-design/01-rebase/)

:arrow_right: obtain a nice linear history
]
.column.w25.middle[
<canvas id='gitRebase0'></canvas>
]
.column.w5.middle[
:arrow_right:
]
.column.w25.middle[
<canvas id='gitRebase1'></canvas>
]
]

---

# `git rebase -i` - Modify existing commits

**what ?** You contribute to a project by fork + pull request. Pull request is denied with comment "squash your commits first".  
**when ?** You contribute to a project by fork + pull request. Pull request is denied with comment "squash your commits first".


# `merge --squash` - Merge as a single commit

TODO

---

# `git` possible workflow

.hcenter.w80[
![](images/workflow_git.png)
]
.hcenter[ [source](https://backlog.com/git-tutorial/branching-workflows/) ]

---

TODO: pull request

* [doc](https://longair.net/blog/2009/04/16/git-fetch-and-merge/)
* [doc](https://devconnected.com/how-to-set-upstream-branch-on-git/)
* [doc](https://www.atlassian.com/git/tutorials/saving-changes/git-stash)
* [doc](https://git-scm.com/book/fr/v2/Les-bases-de-Git-Travailler-avec-des-d%C3%A9p%C3%B4ts-distants)
* [doc](https://backlog.com/git-tutorial/branching-workflows/)

    </textarea>

    <script src="core/javascript/remark.js"></script>
    <script src="core/javascript/katex.min.js"></script>
    <script src="core/javascript/auto-render.min.js"></script>
    <script src="core/javascript/emojify.js"></script>
    <script src="core/javascript/mermaid.js"></script>
    <script src="core/javascript/term.js"></script>
    <script src="core/javascript/jquery-2.1.1.min.js"></script>
    <script src="core/javascript/extend-jquery.js"></script>
    <script src="core/javascript/cinescript.js"></script>
    <script src="core/javascript/gitgraph.js"></script>
    <script>

    // === Remark.js initialization ===
    var slideshow = remark.create({
      highlightStyle: 'monokai',
      countIncrementalSlides: false,
      highlightLines: true
    });

    // === Mermaid.js initialization ===
    mermaid.initialize({
      startOnLoad: false,
      cloneCssStyles: false,
      flowchart:{
        height: 50
      },
      sequenceDiagram:{
        width: 110,
        height: 30
      }
    });

    function initMermaid(s) {
      var diagrams = document.querySelectorAll('.mermaid');
      var i;
      for(i=0;i<diagrams.length;i++){
        if(diagrams[i].offsetWidth>0){
          mermaid.init(undefined, diagrams[i]);
        }
      }
    }

    slideshow.on('afterShowSlide', initMermaid);
    initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);

    
    // === Emojify.js initialization ===
    emojify.run();

    // === Cinescript initialization ===
    $(document).ready(init_cinescripts);

    renderMathInElement(document.body,{delimiters: [{left: "$$", right: "$$", display: true}, {left: "\\(", right: "\\)", display: false}], ignoredTags: [] });

    </script>
    <script src="gitgraph2.js" type="text/javascript"></script>
  </body>
</html>

