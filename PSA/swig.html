<!DOCTYPE html>
<html>
  <head>
    <title>PSA</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="core/fonts/mono.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/animate.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/cinescript.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/style_core.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/mermaid.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/gitgraph.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/style_ensiie.css"> 
  </head>
  <body>
    <textarea id="source" readonly>

layout: true
class: animated fadeIn middle numbers

.footnote[
`PSA` - N. Dubray - ENSIIE - 2018 - [:book:](../index.html)
]

---

# `Swig`

.shadow.hcenter.w15[![](images/david_beazley.png)]


## History
* first author: **David Beazley**
* started in **summer 1995** at LANL
* first release: **Feb. 1996**
* first paper: **June 1996** (`Python` Workshop)

## Characteristics
* **S**implified **W**rapper and **I**nterface **G**enerator
* initial goal: *"make it easy for scientists to put scripting interfaces on physics software"*
* today: **24+** supported languages (even non-scripting ones)


.block[
* Repository: [https://github.com/swig/swig](https://github.com/swig/swig)
* Website: [http://swig.org)](http://swig.org)
* License: `GPLv3`
* These slides are inspired from [Reintroducing Swig](http://www.dabeaz.com/talks.html#reintroducing-swig) and [Swig master class](http://www.dabeaz.com/SwigMaster/SWIGMaster.pdf)
]

---

# `Swig`: supported languages

.hcenter[
* `Tcl` >8.0 (swig-1.1)
* **`Python` >1.5 (swig-1.1)**
* `Perl` >5.003 (swig-1.1)
* `Guile` >1.3.4 (swig-1.1)
* `Java JDK` >1.1 (swig-1.3.6)
* `Ruby` (swig-1.3.6)
* `Mzscheme` (swig-1.3.6)
* `PHP` (swig-1.3.11)
* `Ocaml` (swig-1.3.14)
* `Pike` (swig-1.3.14)
* `C#` (swig-1.3.18)
* `Chicken` scheme compiler (swig-1.3.18)
* `Allegro CL` (swig-1.3.22)
*  `Modula-3` (swig-1.3.22)
* `Lua` (swig-1.3.26)
* `CLISP` with UFFI (swig-1.3.26)
* `Common Lisp` with UFFI (swig-1.3.26)
* `Common Lisp` with CFFI (swig-1.3.28)
* `R` (swig-1.3.30)
* `Octave` (swig-1.3.35)
* `Go` (swig-2.0.1)
* `D` (swig-2.0.2)
* `Javascript` (swig-3.0.1)
* `Scilab` (swig-3.0.5)
]

---

class: top

# Wrapping, binding, porting

## Definition ?

--

:arrow_right: use some existing code **differently** (interface, language, environment) **with minimal rewriting**.

--

## Wrapping
:arrow_right: use with a **different interface**  
:+: same language as the original code  
:+: no need to rewrite the original code  
:+: easy to write  
:+: easy to update if the original code changes  
:warning: tedious work

--

## Binding
:arrow_right: use from a **different language**  
:+: no need to rewrite the original code  
:warning: semi-easy to write  
:+: easy to update if the original code changes  
:warning: may need to write some conversions (types, external libraries, exceptions, etc...)  
:warning: tedious work  
:warning: your code may take a performance hit, since there may be a overhead cost

--

## Porting
:arrow_right: use in a **different environment**  
:warning: semi-easy to write  
:warning: semi-easy to update if the original code changes  
:warning: some rewriting **may be necessary** if some functionalities have changed or are missing

---

# Wrapping, binding, porting

## .hcenter[:warning: **"Wrapping"** is often used instead of **"Binding"** :warning:]

.vspace[]

.hcenter[:arrow_right: in the following, we will use **"Binding"** and **"Wrapping"** indisctinctly.]

---

# Wrapper function

## Real-life examples

* you have discovered a **great `C/C++` library**, and would like to use it from your `Python` code.
* you have written a **very efficient `C/C++` library**, and would like to use it from your `Python` code.
* some part of your `Python` code is **slow**, so you want to replace it by some `C/C++` black magic.
* you have a big, efficient `C/C++` code, and would like to deal with it from `Python`.
* etc...

## Some pure `C/C++` code exists and you want to use it from `Python` ?

:arrow_right: Use a **wrapper function**.

## What is a wrapper function ?
:arrow_right: A **small** piece of code that will **encapsulate** a call to another piece of code,
dealing with the type conversions, exceptions, memory allocation, etc...

To bind a pure `C/C++` function to `Python`, the wrapper function must
1. "convert" `Python` arguments to `C/C++` variables,
2. call the pure `C/C++` function,
3. return the result(s) to `Python`.

---

# Wrapper function example

.row[
.w48[
## .hcenter[\[myfunc0.c\]]
```C++
#include "myfunc0.h"

double myfunc0(double x)
{
  return x * x + 1;
}
```
]
.w48[
## .hcenter[\[myfunc0.h\]]
```C++
#ifndef MYFUNC0_H
#define MYFUNC0_H

double myfunc0(double);

#endif
```
]
]

## .hcenter[\[wrapper_myfunc0.c\]]
```C++
#include <Python.h>
#include "myfunc0.h"

static PyObject *testmod_myfunc0(PyObject *self, PyObject *args)
{
  double x, result;
  if (!PyArg_ParseTuple(args, "d", &x))
  {
    return NULL;
  }

  result = myfunc0(x);

  return Py_BuildValue("d", result);
}

[...] // List of methods, module initialization...
```

---

# Wrapper function compilation

## With `Setuptools`

:arrow_right: create a simple `setup.py` file

## .hcenter[`[setup.py]`]

```Python
from setuptools import setup, Extension

module1 = Extension('_testmod',
                    sources = ['wrapper_myfunc0.c', 'myfunc0.c'])

setup (name = 'TestPackage',
       version = '1.0',
       description = 'This is a test package',
       ext_modules = [module1])
```

## .hcenter[Shell session]
```shell
*$ python setup.py build
running build
running build_ext
building '_testmod' extension
creating build
creating build/temp.linux-x86_64-2.7
gcc -pthread -fno-strict-aliasing -g -fPIC -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/usr/include/python2.7 -c wrapper_myfunc0.c -o build/temp.linux-x86_64-2.7/wrapper_myfunc0.o
gcc -pthread -fno-strict-aliasing -g -fPIC -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/usr/include/python2.7 -c myfunc0.c -o build/temp.linux-x86_64-2.7/myfunc0.o
creating build/lib.linux-x86_64-2.7
gcc -pthread -shared build/temp.linux-x86_64-2.7/testmod.o build/temp.linux-x86_64-2.7/myfunc0.o -lpython2.7 -o build/lib.linux-x86_64-2.7/testmod.so
```

---

# Wrapper function use

## Direct use

:arrow_right: `CPython` can handle `.so` files directly.

```shell
*$ cd build/lib.linux-x86_64-2.7/
*$ ls
testmod.so
*$ python -c 'import testmod; print(testmod.myfunc0(5))'
26.0
```

## Installation with `Setuptools`

```shell
*$ python setup.py install --user
running install
running bdist_egg
running egg_info
[...]
Installed /home/dubrayn/.local/lib/python2.7/site-packages/TestPackage-1.0-py2.7-linux-x86_64.egg
Processing dependencies for TestPackage==1.0
Finished processing dependencies for TestPackage==1.0
*$ python -c 'import testmod; print(testmod.myfunc0(5))'
26.0
```

---

# Wrapper functions workflow

## Another function to wrap ?

:arrow_right: write another wrapper function ! A module is often a simple collection of wrapper functions.

## How to write a wrapper ?
* parse arguments,
* perform some type conversions between `Python` and `C/C++`,
* call the `C/C++` function,
* perform some type conversions between `C/C++` and `Python`,
* return a `PyObject*`,
* update the list of methods of the `Python` module,
* write the module initializer if needed.

## Conclusions
* very tedious process,
* can be error-prone when wrapping many functions.
* can be **very messy** when dealing with `C++` structs, classes, arrays, pointers, templates, etc... 

:arrow_right: let a **wrapper function generator** do the job.

---

# `Swig` usage

## Main idea
:arrow_right: `Swig` generates wrapper functions from the `C/C++` header files.

.vspace[]

## Workflow

1. You list what you want `Swig` to generate a wrapper function for using a `C`-style syntax.
2. `Swig` parses this list and generates the `C/C++` wrapper functions.
3. The resulting `Python` module can be obtained by compiling these wrapper functions.

---

# `Swig` example: initialization

.row[
.w48[
## .hcenter[\[myfunc0.c\]]
```C++
#include "myfunc0.h"

double myfunc0(double x)
{
  return x * x + 1;
}
```
]
.w48[
## .hcenter[\[myfunc0.h\]]
```C++
#ifndef MYFUNC0_H
#define MYFUNC0_H

double myfunc0(double);

#endif
```
]
]

## .hcenter[\[testmod.i\]]
```C++
%module testmod
%{
#include "myfunc0.h"
%}

%include "myfunc0.h"
```

---

# `Swig` example: compilation

## With `Setuptools`

:arrow_right: create a simple `setup.py` file

## .hcenter[`[setup.py]`]

```Python
from setuptools import setup, Extension

module1 = Extension('_testmod',
                    sources = ['testmod.i', 'myfunc0.c'])

setup (name = 'TestPackage',
       version = '1.0',
       description = 'This is a test package',
       ext_modules = [module1])
```

## .hcenter[Shell session]
```shell
*$ python setup.py build
running build
running build_ext
building 'testmod' extension
creating build
creating build/temp.linux-x86_64-2.7
gcc -pthread -fno-strict-aliasing -g -fPIC -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/usr/include/python2.7 -c testmod.c -o build/temp.linux-x86_64-2.7/testmod.o
gcc -pthread -fno-strict-aliasing -g -fPIC -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/usr/include/python2.7 -c myfunc0.c -o build/temp.linux-x86_64-2.7/myfunc0.o
creating build/lib.linux-x86_64-2.7
gcc -pthread -shared build/temp.linux-x86_64-2.7/testmod.o build/temp.linux-x86_64-2.7/myfunc0.o -lpython2.7 -o build/lib.linux-x86_64-2.7/testmod.so
```


    </textarea>

    <script src="core/javascript/remark.js"></script>
    <script src="core/javascript/plotly.js" type="text/javascript"></script>
    <script src="core/javascript/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntil=configured" type="text/javascript"></script>
    <script src="core/javascript/emojify.js" type="text/javascript"></script>
    <script src="core/javascript/mermaid.js" type="text/javascript"></script>
    <script src="core/javascript/term.js" type="text/javascript"></script>
    <script src="core/javascript/jquery-2.1.1.min.js" type="text/javascript"></script>
    <script src="core/javascript/extend-jquery.js" type="text/javascript"></script>
    <script src="core/javascript/cinescript.js" type="text/javascript"></script>
    <script src="core/javascript/gitgraph.js" type="text/javascript"></script>
    <script>

    // === Remark.js initialization ===
    var slideshow = remark.create({
      highlightStyle: 'monokai',
      countIncrementalSlides: false,
      highlightLines: true,
      highlightInlineCode: false
    });

    // === Mermaid.js initialization ===
    mermaid.initialize({
      startOnLoad: false,
      cloneCssStyles: false,
      flowchart:{
        height: 50
      },
      sequenceDiagram:{
        width: 110,
        height: 30
      }
    });

    function initMermaid(s) {
      var diagrams = document.querySelectorAll('.mermaid');
      var i;
      for(i=0;i<diagrams.length;i++){
        if(diagrams[i].offsetWidth>0){
          mermaid.init(undefined, diagrams[i]);
        }
      }
    }

    slideshow.on('afterShowSlide', initMermaid);
    initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);

    // === MathJax.js initialization ===
    MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] } }); 
    MathJax.Hub.Queue(function() { $(MathJax.Hub.getAllJax()).map(function(index, elem) { return(elem.SourceElement()); }).parent().addClass('has-jax'); });
    MathJax.Hub.Configured();

    // === Emojify.js initialization ===
    emojify.run();

    // === Cinescript initialization ===
    $(document).ready(init_cinescripts);

    </script>
  </body>
</html>

