<!DOCTYPE html>
<html>
  <head>
    <title>PSA</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="core/fonts/mono.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/animate.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/cinescript.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/style_core.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/mermaid.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/gitgraph.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/style_ensiie.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/katex.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/asciinema-player.css"> 
  </head>
  <body>
    <textarea id="source" readonly>

layout: true
class: animated fadeIn middle numbers

.footnote[
`PSA` - N. Dubray - ENSIIE - 2023 - [:book:](../index.html)
]

---

# Python virtual environments / packages

.hcenter.shadow.w100[![](images/vr.jpg)]

---

# Introduction

## Possible scenarios

1. a Python project needs some specific dependencies to be used
1. a Python project has a bug in a specific environment and you have to fix it
1. a Python project has non-orthogonal dependencies vs. another project (**or your system**)
1. a Python project has a dependency that breaks another project (**or your system**)

:bulb: How about having **separate** Python environments with specific dependencies ?  
:arrow_right: **Virtual environments** to the rescue !

## Virtual environments

:arrow_right: allows to manage and use a full `Python` stack in a given directory.  
:arrow_right: can also be used with non-Python tools/libraries.  

## Other solutions

:arrow_right: VM, containers, chroot, etc...  
:arrow_right: These solutions offer **encapsulation mechanisms** compared to virtual environments.

---

# Virtual environments

## Why use a virtual environment ?

* to test a new version of a module without stopping a service using it:
 * `criticalService` is running with `superModule==0.9.89`,
 * you think that you have fixed a bug in `superModule==0.9.90`,
 * you want to test `superModule==0.9.90` without stopping or changing `criticalService`...
 * **variant:** use two different versions of the same module on the same system.
* to reproduce a specific user environment (bug hunting):
 * client: "I was using `py27` + `numpy==1.19.3` and it crashed !"
 * you: "I tested with `py27` + `numpy=1.18.7` and it was fine !?"
* to test a project in different environments :
 * does it work with `py36` + `numpy==1.21.5` ?
 * does it work with `py38` + `numpy==1.20.1` ?
* to build a package in a "pure" environment:
 * a heavily-tweaked module `superModule==0.9.89a` is deployed system-wide,
 * you **do NOT want** it to alter the build process of your package...
* to avoid breaking the system by mixing package versions:
 * my project needs `setuptools==59.6.0`,
 * so I install it **system-wide** (`apt install ...`),
 * oops! I broke 30% of my Python system tools... (this is a fictionous example)...
* etc...

---

# Module `venv` - Usage demo

## If needed, install the Python `venv` module

```bash
$ sudo apt install python3-venv
```

:bulb: Install system-wide with the distribution package system.  
:arrow_right: It should be installed by default on a standard Python installation (not like `virtualenv`).


## Usage demo

<pre><code><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">:</font><font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">which</font> python3
/usr/bin/python3
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">:</font><font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">which</font> pip3    
/usr/bin/pip3
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">:</font><font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">ls</font> myVenv                       
ls: cannot access &apos;myVenv&apos;: No such file or directory
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">:</font><font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">python3</font> -m venv myVenv     
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">:</font><font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">ls</font> <u style="text-decoration-style:single">myVenv</u>
<font color="#1A8FFF"><b>bin</b></font>  <font color="#1A8FFF"><b>include</b></font>  <font color="#1A8FFF"><b>lib</b></font>  <font color="#14FFFF"><b>lib64</b></font>  pyvenv.cfg
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">:</font><font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">source</font> <u style="text-decoration-style:single">myVenv/bin/activate</u>
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">(</font><font color="#FD28FF">myVenv</font>):<font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">which</font> python3
/tmp/myVenv/bin/python3
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">(</font><font color="#FD28FF">myVenv</font>):<font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">which</font> pip3   
/tmp/myVenv/bin/pip3
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">(</font><font color="#FD28FF">myVenv</font>):<font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">deactivate</font>
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">:</font><font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">which</font> python3
/usr/bin/python3
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">:</font><font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">which</font> pip3   
/usr/bin/pip3
</code></pre>

---

# Module `venv` - Main commands

## Create the virtual environment  

```bash
$ python3 -m venv myVenv
```

:arrow_right: This creates the `myVenv` directory if needed.  

## Activate the virtual environment  

```bash
$ source myVenv/bin/activate
```

:arrow_right: All "Python" commands will use the `venv` from now.  
:bulb: There are other activation scripts for other shells in `myVenv/bin/`.  

## De-activate the virtual envronment

```bash
$ deactivate
```

:arrow_right: This command has been defined by the sourced `activate*` script.

---

# Module `venv` - Different Python versions

## Create a virtual environment for different Python versions

<pre><code><font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">:</font><font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00"><u style="text-decoration-style:single">sudo</u></font> <font color="#19CB00">apt</font> install python3.11-venv
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following NEW packages will be installed:
  python3.11-venv
0 upgraded, 1 newly installed, 0 to remove and 1 not upgraded.
Need to get 5,730 B of archives.
After this operation, 28.7 kB of additional disk space will be used.
Get:1 http://fr.archive.ubuntu.com/ubuntu jammy-updates/universe amd64 python3.11-venv amd64 3.11.0~rc1-1~22.04 [5,730 B]
Fetched 5,730 B in 0s (43.0 kB/s)<font color="#CECB00">           </font>
Selecting previously unselected package python3.11-venv.
(Reading database ... 528210 files and directories currently installed.)
Preparing to unpack .../python3.11-venv_3.11.0~rc1-1~22.04_amd64.deb ...
Unpacking python3.11-venv (3.11.0~rc1-1~22.04) ...
Setting up python3.11-venv (3.11.0~rc1-1~22.04) ...
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">:</font><font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">python3.11</font> -m venv myVenv_cpy311
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">:</font><font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">source</font> <u style="text-decoration-style:single">myVenv_cpy311/bin/activate</u>
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">(</font><font color="#FD28FF">myVenv_cpy311</font>):<font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">python</font> -V                       
Python 3.11.0rc1
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">(</font><font color="#FD28FF">myVenv_cpy311</font>):<font color="#14FFFF">/tmp</font><font color="#FFFFFF">]</font> <font color="#19CB00">pip</font> -V       
pip 22.0.2 from /tmp/myVenv_cpy311/lib/python3.11/site-packages/pip (python 3.11)
</code></pre>

:arrow_right: A `venv` will use the same Python interpreter as the one used to create it (it is a symlink).

---

class: top

# Module `venv` - Package example

## .hcenter[`C++` + `Armadillo` + `swig` + `setuptools` = Python module]

.vspace[]

.vspace[]

.vspace[]

.vspace[]

.vspace[]

.row.w100[
.col.w30[
.tree[
armanpy_python3
* include
    * armanpy
        * armanpy.i
        * armanpy.hpp
        * armanpy_1d.i
        * armanpy_2d.i
        * armanpy_3d.i
        * numpy.i
* **myclass.cpp** :arrow_left:
* myclass.h
* setup.py
* testmod3.i
* test.py
]
]
.col.w70[
## .hcenter[`myclass.cpp`]
```c++
#include "myclass.h"

Myclass::Myclass(arma::mat _mat) : myMat(_mat)
{
}

arma::mat Myclass::testArma(arma::mat A)
{
  return A.t();
}

arma::mat Myclass::getEmptyArma(int n)
{
  return arma::zeros(n, n);
}
```
]
]

---

class: top

# Module `venv` - Package example

## .hcenter[`C++` + `Armadillo` + `swig` + `setuptools` = Python module]

.vspace[]

.vspace[]

.vspace[]

.vspace[]

.vspace[]

.row.w100[
.col.w30[
.tree[
armanpy_python3
* include
    * armanpy
        * armanpy.i
        * armanpy.hpp
        * armanpy_1d.i
        * armanpy_2d.i
        * armanpy_3d.i
        * numpy.i
* myclass.cpp
* **myclass.h** :arrow_left:
* setup.py
* testmod3.i
* test.py
]
]
.col.w70[
## .hcenter[`myclass.h`]
```c++
#ifndef MYCLASS_H
#define MYCLASS_H

#include <armadillo>

class Myclass
{
  public:
  Myclass(arma::mat _mat = arma::mat());
  arma::mat testArma(arma::mat);
  arma::mat getEmptyArma(int n);
  arma::mat myMat;
};

#endif
```
]
]

---

class: top

# Module `venv` - Package example

## .hcenter[`C++` + `Armadillo` + `swig` + `setuptools` = Python module]

.vspace[]

.vspace[]

.vspace[]

.vspace[]

.vspace[]

.row.w100[
.col.w30[
.tree[
armanpy_python3
* include
    * armanpy
        * armanpy.i
        * armanpy.hpp
        * armanpy_1d.i
        * armanpy_2d.i
        * armanpy_3d.i
        * numpy.i
* myclass.cpp
* myclass.h
* **setup.py** :arrow_left:
* testmod3.i
* test.py
]
]
.col.w70[
## .hcenter[`setup.py`]
```python
from setuptools import setup, Extension

module1 = Extension('_testmod3',
                    include_dirs = ['./include/armanpy/'],
                    libraries = ['m', 'z', 'armadillo'],
                    sources = ['testmod3.i', 'myclass.cpp'],
                    swig_opts = ["-c++", "-Wall", "-I.", "-I./include/armanpy/"])

setup (name = 'package_test',
       py_modules = ['testmod3'],
       version = '1.0',
       description = 'This is a test package',
       ext_modules = [module1])
```
]
]

---

class: top

# Module `venv` - Package example

## .hcenter[`C++` + `Armadillo` + `swig` + `setuptools` = Python module]

.vspace[]

.vspace[]

.vspace[]

.vspace[]

.vspace[]

.row.w100[
.col.w30[
.tree[
armanpy_python3
* include
    * armanpy
        * armanpy.i
        * armanpy.hpp
        * armanpy_1d.i
        * armanpy_2d.i
        * armanpy_3d.i
        * numpy.i
* myclass.cpp
* myclass.h
* setup.py
* **testmod3.i** :arrow_left:
* test.py
]
]
.col.w70[
## .hcenter[`testmod3.i`]
```swig
%module testmod3
%include "stl.i"
%include "std_map.i"
%include "std_string.i"
%include "std_vector.i"
%include "std_vectora.i"
%include "exception.i"

namespace std
{
  %template(map_string_int) map<string, int>;
  %template(map_string_double) map<string, double>;
  %template(map_string_string) map<string, string>;
}

%exception
{
[...]
}

%{
#define SWIG_FILE_WITH_INIT
#include "myclass.h"
%}

%include "armanpy.i"

%include "myclass.h"
```
]
]

---

class: top

# Module `venv` - Package example

## .hcenter[`C++` + `Armadillo` + `swig` + `setuptools` = Python module]

.vspace[]

.vspace[]

.vspace[]

.vspace[]

.vspace[]

.row.w100[
.col.w30[
.tree[
armanpy_python3
* include
    * armanpy
        * armanpy.i
        * armanpy.hpp
        * armanpy_1d.i
        * armanpy_2d.i
        * armanpy_3d.i
        * numpy.i
* myclass.cpp
* myclass.h
* setup.py
* testmod3.i
* **test.py** :arrow_left:
]
]
.col.w70[
## .hcenter[`test.py`]
```python
#!/usr/bin/env python3

import testmod3
import numpy as np

numpyArray = np.array([[0.1, 0.2], [0.3, 0.4]], dtype = np.float64, order = 'F')
print("Initial object:")
print(numpyArray)

mc = testmod3.Myclass(numpyArray)
print("Object in the C++ class (constructor with argument):")
print(mc.myMat)

mc = testmod3.Myclass()
print("Object in the C++ class (empty constructor):")
print(mc.myMat)


a = mc.getEmptyArma(3)
a[0,1] = 1.0
print("Object returned by the C++ method getEmptyArma() and modified:")
print(a)

print("Object returned by the C++ method testArma() (transposition):")
print(mc.testArma(a))
```
]
]

---

# Module `venv` - Package example

## .hcenter[Build and install the package in a `venv` with `setuptools`]

.hcenter[
<asciinema-player src="scripts/setuptools.cast"></asciinema-player>
]

:arrow_right: Installed packages are stored inside the `venv` directory.  
:warning: This direct invocation of `setup.py` is **deprecated**. One must use **`pip`** instead.

---

# Module `venv` - Package example

## .hcenter[Build and install the package in a `venv` with `pip`]

.hcenter[
<asciinema-player src="scripts/pip_module.cast"></asciinema-player>
]

:arrow_right: Installed packages are stored inside the `venv` directory.  
:arrow_right: "`pip` is the **prefered** installer program."

---

# Module `venv` - What was this `pip install` thing ?

## :arrow_right: `pip` can build and install **local packages**  

<pre><code><font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">(</font><font color="#FD28FF">myVenv</font>):<font color="#14FFFF">armanpy_python3</font><font color="#FFFFFF">]</font> <font color="#19CB00">pip</font> install <u style="text-decoration-style:single">.</u>             
Processing /tmp/armanpy_python3
  Preparing metadata (setup.py) ... done
Using legacy &apos;setup.py install&apos; for package-test, since package &apos;wheel&apos; is not installed.
Installing collected packages: package-test
  Running setup.py install for package-test ... done
Successfully installed package-test-1.0</code></pre>


## :arrow_right: `pip` can fetch, [build] and install **remote packages**  

<pre><code> <font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">(</font><font color="#FD28FF">myVenv</font>):<font color="#14FFFF">armanpy_python3</font><font color="#FFFFFF">]</font> <font color="#19CB00">pip</font> install numpy  
Collecting numpy
  Using cached numpy-1.24.3-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (17.3 MB)
Installing collected packages: numpy
Successfully installed numpy-1.24.3
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">(</font><font color="#FD28FF">myVenv</font>):<font color="#14FFFF">armanpy_python3</font><font color="#FFFFFF">]</font> <font color="#19CB00">pip</font> install xkcd==2.4.0
Collecting xkcd==2.4.0
  Downloading xkcd-2.4.0.zip (14 kB)
  Preparing metadata (setup.py) ... done
Using legacy &apos;setup.py install&apos; for xkcd, since package &apos;wheel&apos; is not installed.
Installing collected packages: xkcd
  Running setup.py install for xkcd ... done
Successfully installed xkcd-2.4.0</code></pre>

:arrow_right: Use `pip install package==x.y.z` to install a **specific version** of a package.

---

# Module `venv` - What was this `pip install` thing ?

## :arrow_right: `pip` can **list** installed packages in the current `venv`  

<pre><code><font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">(</font><font color="#FD28FF">myVenv</font>):<font color="#14FFFF">armanpy_python3</font><font color="#FFFFFF">]</font> <font color="#19CB00">pip</font> list     
Package      Version
------------ -------
numpy        1.24.3
package-test 1.0
pip          22.0.2
setuptools   59.6.0
xkcd         2.4.0</code></pre>

## :arrow_right: `pip` can **uninstall** packages in the current `venv`  

<pre><code><font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">(</font><font color="#FD28FF">myVenv</font>):<font color="#14FFFF">armanpy_python3</font><font color="#FFFFFF">]</font> <font color="#19CB00">pip</font> uninstall package-test
Found existing installation: package-test 1.0
Uninstalling package-test-1.0:
  Would remove:
    /tmp/armanpy_python3/myVenv/lib/python3.10/site-packages/_testmod3.cpython-310-x86_64-linux-gnu.so
    /tmp/armanpy_python3/myVenv/lib/python3.10/site-packages/package_test-1.0.egg-info
    /tmp/armanpy_python3/myVenv/lib/python3.10/site-packages/testmod3.py
Proceed (Y/n)? 
  Successfully uninstalled package-test-1.0
<font color="#FFFFFF">[</font><font color="#FFFD00">dubrayn</font><font color="#FFFFFF">@</font><font color="#23FD00">dell5290</font><font color="#FFFFFF">(</font><font color="#FD28FF">myVenv</font>):<font color="#14FFFF">armanpy_python3</font><font color="#FFFFFF">]</font> <font color="#19CB00">pip</font> list                  
Package    Version
---------- -------
numpy      1.24.3
pip        22.0.2
setuptools 59.6.0
xkcd       2.4.0</code></pre>

---

# `PyPi` - The Python Package Index

.hcenter.w40[![](images/logo-pypi.svg)]

:arrow_right: "PyPi helps you find and install software developed and shared by the Python community."

---

# PLOP














---

# Create a `ManyLinux` package


## Compiling and uploading

```bash
$ docker run -it --volume $(pwd):/root/ quay.io/pypa/manylinux_2_28_x86_64
[docker] cd root/
[docker] yum -y install epel-release
[docker] yum -y update
[docker] yum -y install swig armadillo-devel boost-devel
[docker] /opt/python/cp310-cp310/bin/pip3.10 install wheel setuptools numpy twine
[docker] /opt/python/cp310-cp310/bin/pip3.10 wheel . --no-deps -w output
[docker] auditwheel repair output/armanpypsa-*-linux_x86_64.whl -w output
[docker] twine upload output/armanpypsa-*-manylinux_2_28_x86_64.whl -r testpypi
```

## Testing

```bash
$ python3 -m venv venv
$ source venv/bin/activate
$ pip3 install numpy
$ pip3 install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ armanpypsa
$ test_package/test.py
```

---

# ManyLinux demo

.hcenter[
<asciinema-player src="scripts/manylinux.cast"></asciinema-player>
]

---

# `Python` virtual environments

1. VENV
1. what is a virtual env ?
1. why use a virtual env ?
1. create a venv
1. enter a venv
1. leave a venv
1. manually install packages in a venv
1. manually remove packages in a venv
1. manually list packages in a venv


1. PIP
1. the python packages index (Pypi.org)
1. install packages in a venv
1. list packages in a venv
1. remove packages in a venv
1. install project's dependencies

1. create a "standard" python module with PIP
1. pyproject.toml
1. example with setuptools
1. README.md
1. LICENSE
1. build distribution packages (`python3 -m build`)
1. use `twine` to upload package to Pypi





---




# Create a `Python` module in `C/C++`

## What ?
:arrow_right: extend the `Python` language with pure `C/C++` modules  

## Why ?
:+: create new `Python` built-in types  
:+: use `C/C++` library functions and system calls  
:+: use optimized, vectorized, multi-thread `C/C++` code from `Python`

## Warning
:warning: only usable with the `C` extension interface, **specific to `CPython`**  
:arrow_right: for a **portable solution** between `Python` implementations, prefer using `ctypes` or `CFFI` modules

---

# Create a `Python` module in `C/C++`

## Example

We want to write a `Python` module in `C/C++` and use it as

```Python
import testmod

print(testmod.countchars.__doc__) # "Count characters in the input string."

testmod.countchars('some text')   # should return 9
```

---

# Create a `Python` module in `C/C++`

## Step 1

:arrow_right: create a `testmod.c` file and include the `Python.h` header

```C
#include <Python.h>
```

## Remarks

* the `Python.h` header comes with the `Python` development package  
* for **debian** / **ubuntu**: package `libpython3-dev`  
* the `Python.h` header must be included **before any other header** :warning:

---

# Create a `Python` module in `C/C++`

## Step 2

:arrow_right: write the `C/C++` function

```C
static PyObject *testmod_countchars(PyObject *self, PyObject *args)
{
  const char *text;
  int res;

  if (!PyArg_ParseTuple(args, "s", &text))
    return NULL;

  res = strlen(text);

  return Py_BuildValue("i", res);
}
```

## Remarks

* `Python` expects `C` functions to always have 2 arguments: `self`, `args`
* `self` is `NULL` for modules
* for methods, `self` is a pointer to the class instance
* `args` is a pointer to a `Python` tuple containing the arguments

---

# Create a `Python` module in `C/C++`

## Step 3

:arrow_right: write the module's method table

```C
static PyMethodDef testmodMethods[] =
{
  {
    "countchars",
    testmod_countchars,
    METH_VARARGS,
    "Count characters in the input string."
  },
  { NULL, NULL, 0, NULL }
};
```

## Remarks

* list all methods of the module
* format for each method: `{name, pointer, args_format, docstring}`
* `METH_VARARGS` means that the `args` tuple is parsable by `PyArg_ParseTuple()`
* docstring of the method: access with `help(countchars)` or `countchars.__doc__`
* do not forget the special terminating struct :warning:

---

# Create a `Python` module in `C/C++`

## Step 4

:arrow_right: write the module's initialization function

```C
static struct PyModuleDef testmod =
{
  PyModuleDef_HEAD_INIT,
  "testmod", 
  "Super module",          
  -1, // keep global variables
  testmodMethods
};

PyMODINIT_FUNC PyInit_testmod(void)
{
  return PyModule_Create(&testmod);
}
```

## Remarks

* format for each method in struct PyModuleDef : {header initializer, name, documentation, size of per-interpreter state, methods' pointer}
* argument of PyModule_Create() : pointer to the module's definition
* must be named `initxxx()` with `xxx` the name of the module
* `initxxx()` will be called when `Python` imports the module for the first time
* `PyModule_Create()` creates a `Python` module object 
* `PyMODINIT_FUNC` will include `extern "C"` in `C++`

---

# Create a `Python` module in `C/C++`

## .hcenter[`[testmod.c]`]

```C
#include <Python.h>

static PyObject *testmod_countchars(PyObject *self, PyObject *args)
{
  const char *text;
  int res;

  if (!PyArg_ParseTuple(args, "s", &text))
    return NULL;

  res = strlen(text);

  return Py_BuildValue("i", res);
}

static PyMethodDef testmodMethods[] =
{
  {
    "countchars",
    testmod_countchars,
    METH_VARARGS,
    "Count characters in the input string."
  },
  { NULL, NULL, 0, NULL }
};

static struct PyModuleDef testmod =
{
  PyModuleDef_HEAD_INIT,
  "testmod", 
  "Super module",          
  -1, // keep global variables
  testmodMethods
};

PyMODINIT_FUNC PyInit_testmod(void)
{
  return PyModule_Create(&testmod);
}
```

---

# Create a `Python` module in `C/C++`

## Step 5: prepare the compilation with `distutils`

:arrow_right: create a simple `setup.py` file

## .hcenter[`[setup.py]`]

```Python
from distutils.core import setup, Extension

module1 = Extension('testmod',
                    sources = ['testmod.c'])

setup (name = 'TestPackage',
       version = '1.0',
       description = 'This is a test package',
       ext_modules = [module1])
```

## Remarks

* `distutils` is **no more** the prefered method to build and install `Python` modules :warning:

---

# Create a `Python` module in `C/C++`

## Step 5: prepare the compilation with `Setuptools`

:arrow_right: create a simple `setup.py` file

## .hcenter[`[setup.py]`]

```Python
from setuptools import setup, Extension

module1 = Extension('testmod',
                    sources = ['testmod.c'])

setup (name = 'TestPackage',
       version = '1.0',
       description = 'This is a test package',
       ext_modules = [module1])
```

## Remarks

* `Setuptools` is a set of enhancements to the `distutils` module

---

# Create a `Python` module in `C/C++`

## Step 6: compilation

```shell
*$ python setup.py build
running build
running build_ext
building 'testmod' extension
creating build
creating build/temp.linux-x86_64-2.7
  x86_64-linux-gnu-gcc -pthread -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fno-strict-aliasing -Wdate-time -D_FORTIFY_SOURCE=2 -g -fdebug-prefix-map=/build/python2.7-l1RrwO/python2.7-2.7.14=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -I/usr/include/python2.7 -c testmod.c -o build/temp.linux-x86_64-2.7/testmod.o creating build/lib.linux-x86_64-2.7
x86_64-linux-gnu-gcc -pthread -shared -Wl,-O1 -Wl,-Bsymbolic-functions -Wl,-Bsymbolic-functions -Wl,-z,relro -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -Wdate-time -D_FORTIFY_SOURCE=2 -g -fdebug-prefix-map=/build/python2.7-l1RrwO/python2.7-2.7.14=. -fstack-protector-strong -Wformat -Werror=format-security -Wl,-Bsymbolic-functions -Wl,-z,relro -Wdate-time -D_FORTIFY_SOURCE=2 -g -fdebug-prefix-map=/build/python2.7-l1RrwO/python2.7-2.7.14=. -fstack-protector-strong -Wformat -Werror=format-security build/temp.linux-x86_64-2.7/testmod.o -o build/lib.linux-x86_64-2.7/testmod.so
```

---

# Create a `Python` module in `C/C++`

## Step 7: installation

```shell
*$ python setup.py install --user
running install
running bdist_egg
running egg_info
creating TestPackage.egg-info
writing TestPackage.egg-info/PKG-INFO
writing top-level names to TestPackage.egg-info/top_level.txt
writing dependency_links to TestPackage.egg-info/dependency_links.txt
writing manifest file 'TestPackage.egg-info/SOURCES.txt'
reading manifest file 'TestPackage.egg-info/SOURCES.txt'
writing manifest file 'TestPackage.egg-info/SOURCES.txt'
installing library code to build/bdist.linux-x86_64/egg
running install_lib
running build_ext
creating build/bdist.linux-x86_64
creating build/bdist.linux-x86_64/egg
copying build/lib.linux-x86_64-2.7/testmod.so -> build/bdist.linux-x86_64/egg
creating stub loader for testmod.so
byte-compiling build/bdist.linux-x86_64/egg/testmod.py to testmod.pyc
creating build/bdist.linux-x86_64/egg/EGG-INFO
copying TestPackage.egg-info/PKG-INFO -> build/bdist.linux-x86_64/egg/EGG-INFO
copying TestPackage.egg-info/SOURCES.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
copying TestPackage.egg-info/dependency_links.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
copying TestPackage.egg-info/top_level.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
writing build/bdist.linux-x86_64/egg/EGG-INFO/native_libs.txt
zip_safe flag not set; analyzing archive contents...
creating dist
creating 'dist/TestPackage-1.0-py2.7-linux-x86_64.egg' and adding 'build/bdist.linux-x86_64/egg' to it
removing 'build/bdist.linux-x86_64/egg' (and everything under it)
Processing TestPackage-1.0-py2.7-linux-x86_64.egg
Removing /home/dubrayn/.local/lib/python2.7/site-packages/TestPackage-1.0-py2.7-linux-x86_64.egg
Copying TestPackage-1.0-py2.7-linux-x86_64.egg to /home/dubrayn/.local/lib/python2.7/site-packages
TestPackage 1.0 is already the active version in easy-install.pth

Installed /home/dubrayn/.local/lib/python2.7/site-packages/TestPackage-1.0-py2.7-linux-x86_64.egg
Processing dependencies for TestPackage==1.0
Finished processing dependencies for TestPackage==1.0
```

---

# Create a `Python` module in `C/C++`

## Step 8: use your new module :v:

```Python
import testmod

dir(testmod)
# Output:
# ['__builtins__', '__doc__', '__file__', '__name__', '__package__', '__warningregistry__', 'countchars']

print(testmod.countchars.__doc__) # "Count characters in the input string."

testmod.countchars('some text')   # 9
```

---

# Create a `Python` module in `C/C++`

## Variant with keywords: the `C/C++` function

```C
static PyObject *testmod_countchars2(PyObject *self, PyObject *args, PyObject *keywords)
{
  const char *text;
  int other;
  int res;
  static char *kwlist[] = {"text", "other", NULL};

  if (!PyArg_ParseTupleAndKeywords(args, keywords, "si", kwlist, &text, &other))
    return NULL;

* res = strlen(text) + other;

  return Py_BuildValue("i", res);
}
```

---

# Create a `Python` module in `C/C++`

## Variant with keywords: module's method table

```C
static PyMethodDef testmodMethods[] =
  {
    {
      "countchars",
      testmod_countchars,
      METH_VARARGS,
      "Count characters in the input string."
    },
*   {
*     "countchars2",
*     (PyCFunction)testmod_countchars2,
*     METH_VARARGS | METH_KEYWORDS,
*     "Count characters in the input string and add 'other' value (keywords version)."
*   },
    { NULL, NULL, 0, NULL }
  };
```

## Remarks

* do not forget to **cast** your function pointer to a `PyCFunction` :warning:

---

# Create a `Python` module in `C/C++`

## Variant with keywords: compilation

```shell
$ python setup.py build
```

## Installation

```shell
$ python setup.py install --user
```

## Usage

```Python
import testmod

dir(testmod)
# Output:
# ['__builtins__', '__doc__', '__file__', '__name__', '__package__', '__warningregistry__', 'countchars', 'countchars2']

print(testmod.countchars2.__doc__) # "Count characters in the input string and add 'other' value (keywords version)."

testmod.countchars2('some text', 3)                # 12
testmod.countchars2(text = 'some text', other = 3) # 12
testmod.countchars2(other = 3, text = 'some text') # 12

testmod.countchars2(other = 'pipo', text = 'some text')
# Output:
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# TypeError: an integer is required
```

---

# Create a `Python` module in `C/C++`

## Variant with keywords and default value: the `C/C++` function

```C
static PyObject *testmod_countchars3(PyObject *self, PyObject *args, PyObject *keywords)
{
  const char *text;
  int other = 0;
  int res;
  static char *kwlist[] = {"text", "other", NULL};

  if (!PyArg_ParseTupleAndKeywords(args, keywords, "s|i", kwlist, &text, &other))
    return NULL;

  res = strlen(text) + other;

  return Py_BuildValue("i", res);
}
```

---

# Create a `Python` module in `C/C++`

## Variant with keywords and default value: module's method table

```C
static PyMethodDef testmodMethods[] =
  {
    {
      "countchars",
      testmod_countchars,
      METH_VARARGS,
      "Count characters in the input string."
    },
    {
      "countchars2",
      (PyCFunction)testmod_countchars2,
      METH_VARARGS | METH_KEYWORDS,
      "Count characters in the input string and add 'other' value (keywords version)."
    },
*   {
*     "countchars3",
*     (PyCFunction)testmod_countchars3,
*     METH_VARARGS | METH_KEYWORDS,
*     "Count characters in the input string and add 'other' value (keywords and default value version)."
*   },
    { NULL, NULL, 0, NULL }
  };
```

## Remarks

* do not forget to **cast** your function pointer to a `PyCFunction` :warning:

---

# Create a `Python` module in `C/C++`

## Variant with keywords and default value: compilation

```shell
$ python setup.py build
```

## Installation

```shell
$ python setup.py install --user
```

## Usage

```Python
import testmod

dir(testmod)
# Output:
# ['__builtins__', '__doc__', '__file__', '__name__', '__package__', '__warningregistry__', 'countchars', 'countchars2', 'countchars3']

print(testmod.countchars3.__doc__) # "Count characters in the input string and add 'other' value (keywords and default value version)."

testmod.countchars3('some text')                   #  9
testmod.countchars3('some text', -2)               #  7
testmod.countchars3(text = 'some text')            #  9
testmod.countchars3(text = 'some text', other = 2) # 11
testmod.countchars3(other = 2, text = 'some text') # 11
```

---

# Create a `Python` module in `C/C++`

## function `PyArg_ParseTuple()`

* Arguments:

  1. `PyObject *args`
  2. `const char *format`
  3. `...`

## function `PyArg_ParseTupleAndKeywords()`

* Arguments:
  1. `PyObject *args`
  2. `PyObject *kw`
  3. `const char *format`
  4. `char *keywords[]`
  5. `...`

## function `Py_BuildValue()`

* Arguments:
  1. `const char *format`
  2. `...`

* build a `tuple` if 2+ format units
* return a `PyObject*` or `None` if empty format string

---

# Create a `Python` module in `C/C++`

## Format string used by `PyArg_ParseTuple[AndKeywords]()`

* `c`, `s#`, `s*`: `string` of length 1 converted to `char`
* `s`, `s#`, `s*`: `string` or `Unicode` converted to `const char*`
* `z`, `z#`, `z*`: `string` or `Unicode` or `None` converted to `const char*` (`NULL` if `None`)
* `u`, `u#`: `Unicode` converted to `const char*` containing `UTF-16` data
* `es`, `es#`, `et`, `et#`: variants of `s` with encoding conversion
* `b`, `B`: `integer` converted to `unsigned char`
* `h`: `integer` converted to `short int`
* `H`: `integer` converted to `unsigned short int`
* `i`: `integer` converted to `int`
* `I`: `integer` converted to `unsigned int`
* `l`: `integer` converted to `long`
* `k`: `integer` converted to `unsigned long`
* `L`: `integer` converted to `long long`
* `K`: `integer` converted to `unsigned long long`
* `f`: `float` converted to `float`
* `d`: `float` converted to `double`
* `D`: `complex` converted to `Py_complex`
* `|`: the following arguments are **optional**
* ...

---

# Create a `Python` module in `C/C++`

## Format string used by `Py_BuildValue()`

* `c`: `char` converted to `string` of length 1
* `s`, `s#`, `z`, `z#`: `const char*` converted to `string`
* `u`, `u#`: `const char*` converted to `Unicode`
* `i`: `int` converted to `integer`
* `b`: `char` converted to `integer`
* `h`: `short int` converted to `integer`
* `l`: `long` converted to `integer`
* `B`: `unsigned char` converted to `integer`
* `H`: `unsigned short int` converted to `integer`
* `I`: `unsigned int` converted to `integer`
* `k`: `unsigned long` converted to `integer`
* `L`: `long long` converted to `integer`
* `K`: `unsigned long lon` converted to `integer`
* `f`: `float` converted to `float`
* `d`: `double` converted to `float`
* `D`: `Py_complex` converted to `complex`
* `(...)`: `C` values to `tuple`
* `[...]`: `C` values to `list`
* `{...}`: `C` key/value pairs to `dict`
* ...

---

# Create a `Python` module in `C/C++`

## Reference counting

.alert[
* each time a function receives a reference to an object, its reference counter is incremented
* each time a function removes a reference to an object, its reference counter is decremented
* if a reference counter is 0, **the object is deleted**
]

.vspace[]

.block[
* reference counting **avoids memory leaks**
* the `Python` user should not deallocate memory
* reference cycles are detected by `CPython`
]

:arrow_right: almost all methods in `Python` "borrow" references to objects, except `PyTuple_SetItem()` and `PyList_SetItem()` :warning:

## Reference counting macros

* `void Py_INCREF(PyObject*)`  
  increment the reference count, the object must not be `NULL`
* `void Py_DECREF(PyObject*)`  
  decrement the reference count, the object must not be `NULL`
* `void Py_XINCREF(PyObject*)`  
  increment the reference count, in case of a `NULL` object, do nothing
* `void Py_XDECREF(PyObject*)`  
  decrement the reference count, in case of a `NULL` object, do nothing
* `void Py_CLEAR(PyObject*)`  
  decrement the reference count to 0, in case of a `NULL` object, do nothing

---

# Create a `Python` module in `C/C++`

## Return `void` (`None` in `Python`)

```C
Py_INCREF(Py_None);
return Py_None;
```

:arrow_right: the special macro `Py_RETURN_NONE` does the same

---

# Use a `C++` `Python` module from `C/C++`

:arrow_right: create a `testmod.h` header with the declarations of `testmod.c`  
:arrow_right: module initialization functions must be called manually

## .hcenter[`[main.c]`]

```C
#include <Python.h>
#include "testmod.h"

int main(int argc, char *argv[])
{
  /* Pass argv[0] to the Python interpreter */
  Py_SetProgramName(argv[0]);

  /* Initialize the Python interpreter.  Required. */
  Py_Initialize();

  /* Add a static module */
  inittestmod();

  [...]
}
```

## Compilation

```shell
$ gcc -I /usr/include/python2.7/ -c testmod.c
$ gcc -I /usr/include/python2.7/ -c main.c
$ gcc testmod.o main.o -o python_from_c -lpython2.7
```

---

# Conclusion

Writing a `Python` module in `C++` by hand:

* relatively easy to do, thanks to `Python.h`
* very **fine level of control**
* should be done **at least once** by every `Python` developer
* **tedious process** if many objects are to be converted

:arrow_right: Let's [automatize](swig.html) the process !

.hcenter.w60[![](images/factorio.png)]
.hcenter[[source: Factorio](https://www.factorio.com)]

    </textarea>

    <script src="core/javascript/remark.js"></script>
    <script src="core/javascript/katex.min.js"></script>
    <script src="core/javascript/auto-render.min.js"></script>
    <script src="core/javascript/emojify.js"></script>
    <script src="core/javascript/mermaid.js"></script>
    <script src="core/javascript/term.js"></script>
    <script src="core/javascript/jquery-2.1.1.min.js"></script>
    <script src="core/javascript/extend-jquery.js"></script>
    <script src="core/javascript/cinescript.js"></script>
    <script src="core/javascript/gitgraph.js"></script>
    <script src="core/javascript/asciinema-player.js"></script>
    <script>

    // === Remark.js initialization ===
    var slideshow = remark.create({
      highlightStyle: 'monokai',
      countIncrementalSlides: false,
      highlightLines: true
    });

    // === Mermaid.js initialization ===
    mermaid.initialize({
      startOnLoad: false,
      cloneCssStyles: false,
      flowchart:{
        height: 50
      },
      sequenceDiagram:{
        width: 110,
        height: 30
      }
    });

    function initMermaid(s) {
      var diagrams = document.querySelectorAll('.mermaid');
      var i;
      for(i=0;i<diagrams.length;i++){
        if(diagrams[i].offsetWidth>0){
          mermaid.init(undefined, diagrams[i]);
        }
      }
    }

    slideshow.on('afterShowSlide', initMermaid);
    initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);

    
    // === Emojify.js initialization ===
    emojify.run();

    // === Cinescript initialization ===
    $(document).ready(init_cinescripts);

    renderMathInElement(document.body,{delimiters: [{left: "$$", right: "$$", display: true}, {left: "\\(", right: "\\)", display: false}], ignoredTags: [] });

    </script>
  </body>
</html>

